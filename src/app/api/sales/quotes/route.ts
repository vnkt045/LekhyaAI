
import { NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { logAudit } from '@/lib/audit';

// GET /api/sales/quotes
export async function GET(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const search = searchParams.get('search') || '';

    try {
        const whereClause: any = search ? {
            OR: [
                { quoteNumber: { contains: search } },
                {
                    party: {
                        name: { contains: search }
                    }
                }
            ]
        } : {};

        const quotes = await db.quote.findMany({
            where: whereClause,
            include: {
                items: true,
                party: {
                    select: { name: true }
                }
            },
            orderBy: { date: 'desc' },
            take: 50
        });

        return NextResponse.json(quotes);
    } catch (error) {
        console.error('Failed to fetch quotes:', error);
        return NextResponse.json({ error: 'Failed to fetch quotes' }, { status: 500 });
    }
}

// POST /api/sales/quotes
export async function POST(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
        const body = await req.json();

        // Validation (Basic)
        if (!body.partyId || !body.date || !body.items || body.items.length === 0) {
            return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
        }

        const quote = await db.quote.create({
            data: {
                quoteNumber: body.quoteNumber, // Should use the one generated, or let DB handle if logic changed? 
                // Current app sends explicit number generated by backend on form load.
                date: new Date(body.date),
                expiryDate: body.expiryDate ? new Date(body.expiryDate) : null,

                partyId: body.partyId,
                partyName: body.partyName, // Optional, store if provided for quick lookup

                status: 'DRAFT', // Default status

                totalAmount: parseFloat(body.totalAmount) || 0,

                currency: body.currency || 'INR',
                exchangeRate: parseFloat(body.exchangeRate) || 1.0,

                termsAndConditions: body.termsAndConditions,
                notes: body.notes,

                items: {
                    create: body.items.map((item: any) => ({
                        productName: item.productName || item.description, // Fallback if no product name
                        description: item.description,
                        itemId: item.itemId || null,     // Inventory Item Link

                        quantity: parseFloat(item.quantity) || 0,
                        rate: parseFloat(item.rate) || 0,
                        discount: parseFloat(item.discount) || 0,

                        taxableAmount: parseFloat(item.taxableAmount) || 0,
                        taxAmount: parseFloat(item.taxAmount) || 0,
                        totalAmount: parseFloat(item.totalAmount) || 0,

                        hsnSac: item.hsnSac,
                        gstRate: parseFloat(item.gstRate) || 0
                    }))
                }
            },
            include: {
                items: true
            }
        });

        // Audit Log
        await logAudit({
            entityType: 'quote',
            entityId: quote.id,
            action: 'CREATE',
            newValue: quote,
            req
        });

        return NextResponse.json(quote, { status: 201 });
    } catch (error) {
        console.error('Quote creation error:', error);
        return NextResponse.json({ error: 'Failed to create quote' }, { status: 500 });
    }
}
